// Braine Desktop - Game Canvases
// Visual renderers for each game type

import { Theme } from "theme.slint";
import { GameState } from "types.slint";

// ═══════════════════════════════════════════════════════════════════════════
// Spot Game Canvas
// ═══════════════════════════════════════════════════════════════════════════

export component SpotCanvas inherits Rectangle {
    in property <GameState> game;
    
    background: Theme.bg-dark;
    border-color: Theme.border;
    border-width: 2px;
    
    // Center divider
    Rectangle {
        x: parent.width / 2 - 1px;
        width: 2px;
        height: parent.height;
        background: #ffffff20;
    }
    
    // Left label
    Text {
        x: parent.width * 0.25 - 25px;
        y: 20px;
        text: "LEFT";
        color: Theme.text-secondary;
        font-size: 18px;
    }
    
    // Right label
    Text {
        x: parent.width * 0.75 - 30px;
        y: 20px;
        text: "RIGHT";
        color: Theme.text-secondary;
        font-size: 18px;
    }
    
    // Spot (bright yellow circle)
    Rectangle {
        x: ((game.kind == "bandit") ? (parent.width * 0.5) :
            (((game.kind == "spot_reversal") ? (game.spot-is-left != game.reversal-active) : game.spot-is-left)
                ? parent.width * 0.25 : parent.width * 0.75)) - 40px;
        y: parent.height / 2 - 40px;
        width: 80px;
        height: 80px;
        background: Theme.accent-yellow;
        border-radius: 40px;
        opacity: game.response-made ? 0.25 : 1.0;
    }
    
    // Instruction text (when waiting for response)
    if !game.response-made: Text {
        x: 0px;
        y: parent.height - 40px;
        width: parent.width;
        text: (game.kind == "bandit") ? "Choose LEFT (A) or RIGHT (D)" :
              ((game.spot-is-left != game.reversal-active) ? "← Press LEFT (A)" : "Press RIGHT (D) →");
        color: Theme.text-primary;
        font-size: 16px;
        horizontal-alignment: center;
    }
    
    // Choice indicator bar (brain's selected action)
    Rectangle {
        y: parent.height - 10px;
        height: 4px;
        background: Theme.accent-blue;

        x: (game.chosen-action == "left") ? 0px : (game.chosen-action == "right") ? (parent.width / 2) : 0px;
        width: (game.chosen-action == "left" || game.chosen-action == "right") ? (parent.width / 2) : 0px;
        opacity: game.response-made ? 0.9 : 0.0;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Bandit Canvas (stochastic reward, no spot location)
// ═══════════════════════════════════════════════════════════════════════════

export component BanditCanvas inherits Rectangle {
    in property <GameState> game;

    background: Theme.bg-dark;
    border-color: Theme.border;
    border-width: 2px;

    // Two "arms" (left/right)
    Rectangle {
        x: 0px;
        y: 0px;
        width: parent.width / 2;
        height: parent.height;
        background: #00000000;
    }
    Rectangle {
        x: parent.width / 2;
        y: 0px;
        width: parent.width / 2;
        height: parent.height;
        background: #00000000;
    }

    Rectangle {
        x: parent.width / 2 - 1px;
        width: 2px;
        height: parent.height;
        background: #ffffff14;
    }

    Text {
        x: parent.width * 0.25 - 35px;
        y: 18px;
        text: "ARM A";
        color: Theme.text-secondary;
        font-size: 16px;
    }
    Text {
        x: parent.width * 0.75 - 35px;
        y: 18px;
        text: "ARM B";
        color: Theme.text-secondary;
        font-size: 16px;
    }

    // Choice highlight
    Rectangle {
        x: (game.chosen-action == "left") ? 10px : (game.chosen-action == "right") ? (parent.width / 2 + 10px) : 10px;
        y: 52px;
        width: parent.width / 2 - 20px;
        height: parent.height - 64px;
        background: Theme.accent-blue;
        opacity: game.response-made ? 0.08 : 0.0;
        border-radius: 8px;
    }

    // Reward flash (last reward)
    Rectangle {
        width: 14px;
        height: 14px;
        border-radius: 7px;
        x: parent.width / 2 - self.width / 2;
        y: parent.height / 2 - self.height / 2;
        background: (game.last-reward > 0.0) ? Theme.accent-green : (game.last-reward < 0.0) ? Theme.accent-red : Theme.text-secondary;
        opacity: game.response-made ? 0.65 : 0.15;
    }

    if !game.response-made: Text {
        x: 0px;
        y: parent.height - 40px;
        width: parent.width;
        text: "Choose ARM A (A) or ARM B (D)";
        color: Theme.text-primary;
        font-size: 14px;
        horizontal-alignment: center;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Pong Canvas (ball + paddle)
// ═══════════════════════════════════════════════════════════════════════════

export component PongCanvas inherits Rectangle {
    in property <GameState> game;

    background: Theme.bg-dark;
    border-color: Theme.border;
    border-width: 2px;

    // Playfield bounds
    field := Rectangle {
        x: 12px;
        y: 12px;
        width: parent.width - 24px;
        height: parent.height - 24px;
        background: transparent;
        border-width: 0px;
    }

    // Paddle (left)
    Rectangle {
        property <length> paddle_w: 10px;
        property <length> paddle_h: max(24px, field.height * game.pong-paddle-half-height);
        width: self.paddle_w;
        height: self.paddle_h;
        x: field.x + 8px;
        y: field.y + (0.5 - 0.5 * game.pong-paddle-y) * (field.height - self.height);
        background: Theme.accent-blue;
        border-radius: 3px;
        opacity: 0.95;
    }

    // Ball (pos-x,pos-y are in [-1,1])
    Rectangle {
        width: 10px;
        height: 10px;
        border-radius: 5px;
        background: Theme.accent-yellow;
        x: field.x + (0.5 + 0.5 * game.pos-x) * (field.width - self.width);
        y: field.y + (0.5 - 0.5 * game.pos-y) * (field.height - self.height);
        opacity: game.pong-ball-visible ? 0.95 : 0.0;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SpotXY Canvas (2D dot tracking)
// ═══════════════════════════════════════════════════════════════════════════

export component SpotXYCanvas inherits Rectangle {
    in property <GameState> game;
    in property <int> frame;

    background: Theme.bg-dark;
    border-color: Theme.border;
    border-width: 2px;

    // Fixed drawing bounds for the grid
    grid := Rectangle {
        property <length> size: max(140px, min(parent.width, parent.height) - 24px);
        width: self.size;
        height: self.size;
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        background: transparent;
        border-width: 0px;
    }

    // Binary mode divider (x = 0)
    if game.spotxy-grid-n <= 0: Rectangle {
        x: grid.x + grid.width / 2 - 1px;
        width: 2px;
        y: grid.y;
        height: grid.height;
        background: #ffffff20;
    }

    // Grid mode lines (N×N)
    if game.spotxy-grid-n > 0: Rectangle {
        x: 0px; y: 0px; width: 0px; height: 0px; background: transparent;

        // Vertical lines k=1..7
        if game.spotxy-grid-n > 1: Rectangle { width: 1px; height: grid.height; x: grid.x + (1.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 2: Rectangle { width: 1px; height: grid.height; x: grid.x + (2.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 3: Rectangle { width: 1px; height: grid.height; x: grid.x + (3.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 4: Rectangle { width: 1px; height: grid.height; x: grid.x + (4.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 5: Rectangle { width: 1px; height: grid.height; x: grid.x + (5.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 6: Rectangle { width: 1px; height: grid.height; x: grid.x + (6.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 7: Rectangle { width: 1px; height: grid.height; x: grid.x + (7.0 / (game.spotxy-grid-n * 1.0)) * grid.width - self.width / 2; y: grid.y; background: Theme.border; opacity: 0.65; }

        // Horizontal lines k=1..7
        if game.spotxy-grid-n > 1: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (1.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 2: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (2.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 3: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (3.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 4: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (4.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 5: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (5.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 6: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (6.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
        if game.spotxy-grid-n > 7: Rectangle { width: grid.width; height: 1px; x: grid.x; y: grid.y + (7.0 / (game.spotxy-grid-n * 1.0)) * grid.height - self.height / 2; background: Theme.border; opacity: 0.65; }
    }

    // Flash correct cell (grid mode)
    if game.spotxy-grid-n > 0 && game.spotxy-correct-ix >= 0 && game.spotxy-correct-iy >= 0: Rectangle {
        property <float> n: game.spotxy-grid-n * 1.0;
        property <float> ix: game.spotxy-correct-ix * 1.0;
        property <float> iy: (game.spotxy-grid-n - 1 - game.spotxy-correct-iy) * 1.0;
        x: grid.x + (ix / n) * grid.width;
        y: grid.y + (iy / n) * grid.height;
        width: grid.width / n;
        height: grid.height / n;
        background: Theme.accent-green;
        border-color: Theme.accent-green;
        border-width: 2px;
        opacity: game.response-made ? ((Math.mod(frame, 16) < 8) ? 0.18 : 0.04) : 0.0;
    }

    // Flash chosen cell if incorrect
    if game.spotxy-grid-n > 0 && game.spotxy-chosen-ix >= 0 && game.spotxy-chosen-iy >= 0
        && (game.spotxy-correct-ix < 0 || game.spotxy-correct-iy < 0
            || game.spotxy-chosen-ix != game.spotxy-correct-ix
            || game.spotxy-chosen-iy != game.spotxy-correct-iy): Rectangle {
        property <float> n: game.spotxy-grid-n * 1.0;
        property <float> ix: game.spotxy-chosen-ix * 1.0;
        property <float> iy: (game.spotxy-grid-n - 1 - game.spotxy-chosen-iy) * 1.0;
        x: grid.x + (ix / n) * grid.width;
        y: grid.y + (iy / n) * grid.height;
        width: grid.width / n;
        height: grid.height / n;
        background: Theme.accent-blue;
        border-color: Theme.accent-blue;
        border-width: 2px;
        opacity: game.response-made ? ((Math.mod(frame, 12) < 6) ? 0.22 : 0.05) : 0.0;
    }

    // Dot position
    Rectangle {
        width: 12px;
        height: 12px;
        border-radius: 6px;
        background: Theme.accent-yellow;
        x: grid.x + (0.5 + 0.5 * game.pos-x) * (grid.width - self.width);
        y: grid.y + (0.5 - 0.5 * game.pos-y) * (grid.height - self.height);
        opacity: game.response-made ? 0.35 : 1.0;
    }

    Text {
        x: 10px;
        y: 10px;
        text: game.spotxy-eval ? "EVAL" : "TRAIN";
        color: Theme.text-secondary;
        font-size: 14px;
    }

    // Choice indicator bar (binary mode only)
    if game.spotxy-grid-n <= 0: Rectangle {
        y: parent.height - 10px;
        height: 4px;
        background: Theme.accent-blue;

        x: (game.chosen-action == "left") ? 0px : (game.chosen-action == "right") ? (parent.width / 2) : 0px;
        width: (game.chosen-action == "left" || game.chosen-action == "right") ? (parent.width / 2) : 0px;
        opacity: game.response-made ? 0.9 : 0.0;
    }
}
